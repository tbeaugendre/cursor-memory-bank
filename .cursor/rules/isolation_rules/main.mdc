---
description: main rule
globs: main.mdc
alwaysApply: false
---
# üîç ISOLATION-FOCUSED MEMORY BANK SYSTEM

üö® CRITICAL RULE: MEMORY BANK CREATION IS MANDATORY üö®
Memory Bank MUST be created BEFORE any other operation in ANY command
NO process can continue without verifying Memory Bank existence

> **TL;DR:** This system is designed to work with Cursor Commands (slash commands), where each command loads only the rules it needs. The system uses visual Mermaid diagrams and selective document loading to optimize context usage.

## üß≠ COMMAND-BASED VISUAL MAPS

```mermaid
graph TD
    subgraph Commands["Cursor Slash Commands"]
        VAN["/van<br>Initialization"] --> PLAN["/plan<br>Task Planning"]
        PLAN --> Creative["/creative<br>Design Decisions"]
        Creative --> Implement["/implement<br>Code Implementation"]
        Implement --> Reflect["/reflect<br>Task Review"]
        Reflect --> Archive["/archive<br>Documentation"]
    end
    
    VAN -.->|"Loads"| VANRules["‚Ä¢ main.md<br>‚Ä¢ platform-awareness.md<br>‚Ä¢ file-verification.md<br>‚Ä¢ workflow-init.md"]
    PLAN -.->|"Loads"| PLANRules["‚Ä¢ main.md<br>‚Ä¢ task-tracking.md<br>‚Ä¢ planning-process.md"]
    Creative -.->|"Loads"| CreativeRules["‚Ä¢ main.md<br>‚Ä¢ creative-phase.md<br>‚Ä¢ design-patterns.md"]
    Implement -.->|"Loads"| ImplementRules["‚Ä¢ main.md<br>‚Ä¢ command-execution.md<br>‚Ä¢ implementation-guide.md"]
    Reflect -.->|"Loads"| ReflectRules["‚Ä¢ main.md<br>‚Ä¢ reflection-format.md"]
    Archive -.->|"Loads"| ArchiveRules["‚Ä¢ main.md<br>‚Ä¢ archiving-guide.md"]
    
    QA["/qa<br>Quality Assurance"] -.->|"Can be called<br>from any point"| VAN & PLAN & Creative & Implement & Reflect
```

## üìã MEMORY BANK VERIFICATION - MANDATORY IN ALL COMMANDS

```mermaid
graph TD
    Start["Command Activation"] --> CheckMemBank{"Memory Bank<br>Exists?"}
    
    CheckMemBank -->|"No"| CreateMemBank["CREATE MEMORY BANK<br>[CRITICAL STEP]"]
    CheckMemBank -->|"Yes"| VerifyMemBank["Verify Memory Bank<br>Structure"]
    
    CreateMemBank --> VerifyCreation{"Creation<br>Successful?"}
    VerifyCreation -->|"No"| AbortAll["‚õî ABORT ALL OPERATIONS<br>Fix Memory Bank First"]
    VerifyCreation -->|"Yes"| VerifyMemBank
    
    VerifyMemBank --> StructureCheck{"Structure<br>Valid?"}
    StructureCheck -->|"No"| FixStructure["Fix Memory Bank<br>Structure"]
    StructureCheck -->|"Yes"| ContinueCommand["Continue with<br>Command Operations"]
    
    FixStructure --> VerifyFix{"Fix<br>Successful?"}
    VerifyFix -->|"No"| AbortAll
    VerifyFix -->|"Yes"| ContinueCommand
    
    style CheckMemBank fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style CreateMemBank fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style VerifyCreation fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style AbortAll fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style StructureCheck fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style FixStructure fill:#ff5555,stroke:#dd3333,color:white
    style VerifyFix fill:#ff5555,stroke:#dd3333,color:white
```

## üìö VISUAL PROCESS MAPS

Each command has its own visual process map:

- @VAN Mode Map - `/van` initialization
- @PLAN Mode Map - `/plan` task planning
- @CREATIVE Mode Map - `/creative` design decisions
- @IMPLEMENT Mode Map - `/implement` code implementation
- @REFLECT Mode Map - `/reflect` task review
- @ARCHIVE Mode Map - `/archive` documentation

## üîÑ FILE STATE VERIFICATION

In this isolation-focused approach, Memory Bank files maintain continuity between commands:

```mermaid
graph TD
    subgraph "Memory Bank Files"
        tasks["tasks.md<br>Source of Truth"]
        active["activeContext.md<br>Current Focus"]
        creative["creative-*.md<br>Design Decisions"]
        progress["progress.md<br>Implementation Status"]
    end
    
    VAN["/van"] -->|"Creates/Updates"| tasks
    VAN -->|"Creates/Updates"| active
    
    PLAN["/plan"] -->|"Reads"| tasks
    PLAN -->|"Reads"| active
    PLAN -->|"Updates"| tasks
    
    Creative["/creative"] -->|"Reads"| tasks
    Creative -->|"Creates"| creative
    Creative -->|"Updates"| tasks
    
    Implement["/implement"] -->|"Reads"| tasks
    Implement -->|"Reads"| creative
    Implement -->|"Updates"| tasks
    Implement -->|"Updates"| progress
    
    Reflect["/reflect"] -->|"Reads"| tasks
    Reflect -->|"Reads"| progress
    Reflect -->|"Updates"| tasks
    
    Archive["/archive"] -->|"Reads"| tasks
    Archive -->|"Reads"| progress
    Archive -->|"Archives"| creative
```

## üìã COMMAND TRANSITION PROTOCOL

```mermaid
sequenceDiagram
    participant User
    participant CurrentCmd as Current Command
    participant NextCmd as Next Command
    
    CurrentCmd->>CurrentCmd: Complete Phase Requirements
    CurrentCmd->>User: "Phase complete. NEXT: /[command]"
    User->>NextCmd: Execute Next Command
    NextCmd->>NextCmd: Verify Required File State
    
    alt File State Valid
        NextCmd->>User: "Continuing from previous phase..."
    else File State Invalid
        NextCmd->>User: "Required files not in expected state"
        NextCmd->>User: "Run /[previous command] to complete requirements"
    end
```

## üíª PLATFORM-SPECIFIC COMMANDS

| Action | Windows | Mac/Linux |
|--------|---------|-----------|
| Create file | `echo. > file.ext` | `touch file.ext` |
| Create directory | `mkdir directory` | `mkdir -p directory` |
| Change directory | `cd directory` | `cd directory` |
| List files | `dir` | `ls` |
| Show file content | `type file.ext` | `cat file.ext` |

## ‚ö†Ô∏è COMMAND EFFICIENCY GUIDANCE

For optimal performance, use efficient command chaining when appropriate:

```
# Efficient command chaining examples:
mkdir -p project/{src,tests,docs} && cd project
grep "TODO" $(find . -name "*.js")
npm install && npm start
```

Refer to [command-execution.mdc](mdc:.cursor/rules/isolation_rules/Core/command-execution.mdc) for detailed guidance.

## üöÄ QUICK START

1. **Start a task**: Type `/van` in chat to initialize
2. **Plan the work**: Type `/plan` to create implementation plan
3. **Design decisions**: Type `/creative` for complex design work
4. **Build it**: Type `/implement` to execute the plan
5. **Review**: Type `/reflect` to capture learnings
6. **Document**: Type `/archive` to complete the task
7. **Validate**: Type `/qa` at any point for quality checks
